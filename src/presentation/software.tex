%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MATLAB Implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MATLAB Implementation}
\begin{frame}[label=matlab]{MATLAB Implementation}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% C Implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C Implementation}
\begin{frame}[label=c]{C Implementation}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Algorithm Profiling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Algorithm Profiling}
\begin{frame}[label=profiling,fragile]{Algorithm Profiling}
    \profilingPlots{testoutrank}{runningex40k}{connect4}

    \note{These graphs show the relative execution times of functions comprising
    the anomaly detection algorithm, executed on 3 different data sets. The
    graphs for the other 18 data sets are very similar.

    These graphs shows that the vast majority of the algorithm's execution time
    is attributed to the \verb+distance_squared+ function --- a simple function
    which returns the square of the Euclidean distance between two given
    vectors.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Block Size Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Block Size Analysis}
\begin{frame}[label=functionExecutionTime,fragile]
        {Function Execution Time}
        {\verb+TopN_Outlier_Pruning_Block+}
    \blockSizeProfilingPlot{function_execution_time}

    \note{This graph shows the total execution time of the
    verb+TopN_Outlier_Pruning_Block+ function, sampled using 21 data sets with a
    size ranging from 441 2-dimensional vectors to 67557 43-dimensional vectors.

    Each dataset was profiled with 13 different block sizes ranging from $10^0$
    to $10^6$. In addition, a modified algorithm which operated without blocking
    was profiled for comparison.

    Each coloured plot in this graph represents a single data set. The solid
    lines show how the total execution time varies with block size. The dashed
    plots of the same colour illustrate a baseline comparison to the modified
    (no blocking) algorithm.

    An interesting observation from this graph shows that there is no
    significant difference in the algorithm's performance for block sizes from
    $10^0$ to $10^3$.
    }
\end{frame}

\begin{frame}[label=distanceCalls]{Distance Calls}
    \blockSizeProfilingPlot{distance_calls}
\end{frame}

\begin{frame}[label=vectorsPruned]{Vectors Pruned}
    \blockSizeProfilingPlot{vectors_pruned}
\end{frame}

\begin{frame}[label=runTimeComplexity]{Function Run Time Complexity}
    \begin{columns}[c]
        \column{0.5\textwidth}
        \blockSizeProfilingPlot{function_run_time_complexity.lin}

        \column{0.5\textwidth}
        \blockSizeProfilingPlot{function_run_time_complexity.log}
    \end{columns}
\end{frame}