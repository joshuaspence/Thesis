%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Method
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Method}
\begin{frame}[label=method]{Method}
    \note<1>{And so, just to provide a quick outline of the various
        implementation stages that were iterated through in order to realise my
        hardware design.}

    \begin{enumerate}
        \item<2-> MATLAB source code
        \note<2>{The initial implementation of the algorithm, as provided by
            Khoa, comprised of MATLAB source code. This code formed the basis of
            my analysis and benchmarking.}

        \bigskip
        \item<3-> MATLAB source code + MEX file
        \note<3>{Following from this, a subset of the MATLAB source code (namely
            that of the function that seemed most promising for a hardware
            implementation) was rewritten as C++ source code using MEX header
            files to interact with MATLAB.}

        \bigskip
        \item<4-> C++ source code
        \note<4>{The next stage involved the complete separation of the chosen
            function from the algorithm framework in MATLAB. The source code was
            rewritten as pure C++ and additional wrappers were created to
            facilitate isolated testing.}

        \bigskip
        \item<5-> AutoESL high level synthesis
        \note<5>{Further analysis of the C++ function implementation provided
            additional insight into the algorithm's key properties and
            weaknesses, from which a smaller subset of source code was selected
            for high level synthesis --- a process to convert C++ source code
            into a low level hardware description language.}

        \bigskip
        \item<6-> Hardware design
        \note<6>{Following from the high level synthesis, and using the Xilinx
            design suite, I was able to transform my high-level software design
            into a low-level, parallelised hardware design.}
    \end{enumerate}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Algorithm Profiling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Algorithm Profiling}
\begin{frame}[label=profiling]{Algorithm Profiling}
        {\escape{TopN_Outlier_Pruning_Block}}
    \profilingPlots{testoutrank}{runningex40k}{connect4}

    \note{These graphs show the relative execution times of functions comprising
        the anomaly detection algorithm, executed on 3 different data sets. The
        graphs for the other 18 data sets are very similar.

        These graphs shows that the vast majority of the algorithm's execution
        time is attributed to the \escape{distance_squared} function --- a
        simple function which returns the square of the Euclidean distance
        between two given vectors.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Block Size Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Block Size Analysis}
\begin{frame}[label=functionExecutionTime]{Function Execution Time}
        {\escape{TopN_Outlier_Pruning_Block}}
    \blockSizeProfilingPlot{function_execution_time}

    \note{This graph shows the total execution time of the
        \escape{TopN_Outlier_Pruning_Block} function, sampled using 21 data
        sets with a size ranging from 441 2-dimensional vectors to 67557
        43-dimensional vectors.

        Each dataset was profiled with 13 different block sizes ranging from
        $10^0$ to $10^6$. In addition, a modified algorithm which operated
        without blocking was profiled for comparison.

        Each coloured plot in this graph represents a single data set. The solid
        lines show how the total execution time varies with block size. The
        dashed plots of the same colour illustrate a baseline comparison to the
        modified (no blocking) algorithm.

        An interesting observation from this graph shows that there is no
        significant difference in the algorithm's performance for block sizes
        from $10^0$ to $10^3$.}
\end{frame}

\begin{frame}{Distance Calls and Vectors Pruned}
        {\escape{TopN_Outlier_Pruning_Block}}
    \begin{columns}[c]
        \column{0.5\textwidth}
        \begin{figure}[H]
            \blockSizeProfilingPlot{distance_calls}
            \caption{Distance calls}
        \end{figure}

        \column{0.5\textwidth}
        \begin{figure}[H]
            \blockSizeProfilingPlot{vectors_pruned}
            \caption{Vectors pruned}
        \end{figure}
    \end{columns}
\end{frame}

\begin{frame}[label=runTimeComplexity]{Function Run Time Complexity}
        {\escape{TopN_Outlier_Pruning_Block}}
    \begin{columns}[c]
        \column{0.5\textwidth}
        \begin{figure}[H]
            \blockSizeProfilingPlot{function_run_time_complexity.lin}
            \caption{Linear plot}
        \end{figure}

        \column{0.5\textwidth}
        \begin{figure}[H]
            \blockSizeProfilingPlot{function_run_time_complexity.log}
            \caption{Logarithmic plot}
        \end{figure}
    \end{columns}
\end{frame}
